%{ 
open MiniML.AbstractSyntaxTree

#if DEBUG
let debugPrint s = printfn "### %s" s
#else
let debugPrint s = ignore s
#endif


%}
 
%start File
 
%token DUMMY

// terminal tokens
%token COMMA SEMICOLON COLON
%token <decimal> NUMBER
%token <string> ID
%token PLUS MINUS TIMES DIVIDE LPAREN RPAREN EQUAL NOT_EQUAL LT GT LT_EQUAL GT_EQUAL
%token AND OR
%token EOF

%token MODULE
%token LET
%token BIND
%token RETURN

%token IF THEN ELSE
%token MATCH WITH PIPE FAT_ARROW

%token INDENT DEDENT NEWLINE

// associativity and precedences
%left AND OR
%left PLUS MINUS 
%left TIMES DIVIDE
%left EQUAL NOT_EQUAL LT GT LT_EQUAL GT_EQUAL


// return type of Expr
%type <MiniML.AbstractSyntaxTree.File> File

%% 

File:
    MODULE ID NEWLINE
    Statements
    EOF
        { Module ($2, $4) }

Statements:
    Statement { [$1] }
    | Statements NEWLINE Statement { $1 @ [$3] }

Statement:
    LetStatement
        { debugPrint $"let {$1}"; $1 }

    | ExpressionStatement
        { debugPrint $"expression {$1}"; $1 }

    | IfStatement
        { debugPrint $"if {$1}"; $1 }

    | SwitchStatement
        { debugPrint $"match {$1}"; $1 }

IfStatement:
    | IF Expression THEN BlockStatements Else
        { debugPrint $"IfThenElse"; IfThenElse ($2, $4, $5) }

Else:
    /* empty */
        { [] }

    | NEWLINE ELSE BlockStatements
        { $3 }

BlockStatements:
    Statement { [$1] }
    | INDENT Statements DEDENT { $2 }
 
LetStatement:
    LET ID BIND BlockStatements
        { Let ($2, $4) }

ExpressionStatement:
    Expression
        { Return $1 }


SwitchStatement:
    MATCH Expression WITH INDENT SwitchCases DEDENT
        { Switch ($2, $5) }

SwitchCases:
    SwitchCase
        { [$1] }
    
    | SwitchCases NEWLINE SwitchCase
        { $1 @ [ $3 ] }

SwitchCase:
    Expression FAT_ARROW BlockStatements
        { $1, $3 }

Expression:
    NUMBER
        { Number $1 }
    
    | ID
        { Symbol $1 }
    
    | Expression PLUS Expression
        { Function (Plus, $1, $3) } 
    
    | Expression MINUS Expression
        { Function (Minus, $1, $3) }

    | Expression TIMES Expression
        { Function (Times, $1, $3) }

    | Expression DIVIDE Expression
        { Function (Divide, $1, $3) }

    | Expression EQUAL Expression
        { Function (Equal, $1, $3) }

    | Expression NOT_EQUAL Expression
        { Function (NotEqual, $1, $3) }

    | Expression LT Expression
        { Function (LowerThan, $1, $3) }

    | Expression LT_EQUAL Expression
        { Function (LowerThanOrEqual, $1, $3) }

    | Expression GT Expression
        { Function (GreaterThan, $1, $3) }

    | Expression GT_EQUAL Expression
        { Function (GreaterThanOrEqual, $1, $3) }

    | Expression AND Expression
        { Function (And, $1, $3) }

    | Expression OR Expression
        { Function (Or, $1, $3) }

    | LPAREN Expression RPAREN
        { $2 }

    | ID LPAREN CallTupleArgs RPAREN
        { FunctionCall ($1, $3) }

        //   | SYMBOL CallPartialArgs { PartialFunctionCall ($1, $2) }

CallTupleArgs:
    /* empty */
        { [] }

    | CallArgs
        { $1 }

CallArgs:
    Expression
        { [$1] }
    
    | CallArgs COMMA Expression
        { $1 @ [ $3 ] }

CallPartialArgs:
    Expression
        { [$1] }
    
    | CallPartialArgs Expression
        { $1 @ [ $2 ] }
