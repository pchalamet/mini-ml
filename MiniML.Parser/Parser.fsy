%{ 
open MiniML.AbstractSyntaxTree

#if DEBUG
let debugPrint s = printfn "### %s" s
#else
let debugPrint s = ignore s
#endif


%}
 
%start File
 
%token DUMMY

// terminal tokens
%token COMMA SEMICOLON COLON PIPE
%token <decimal> NUMBER
%token <string> ID
%token PLUS MINUS TIMES DIVIDE LPAREN RPAREN EQUAL NOT_EQUAL LT GT LT_EQUAL GT_EQUAL
%token AND OR
%token EOF

%token MODULE
%token LET
%token BIND
%token RETURN

%token IF THEN ELSE
%token MATCH WITH FAT_ARROW
%token WHILE DO

%token INDENT DEDENT NEWLINE

// associativity and precedences
%left AND OR
%left PLUS MINUS 
%left TIMES DIVIDE
%left EQUAL NOT_EQUAL LT GT LT_EQUAL GT_EQUAL


// return type of Expr
%type <MiniML.AbstractSyntaxTree.File> File

%% 

File:
    MODULE ID NEWLINE
    Statements
    EOF { Module ($2, $4) }

Statements:
    | Statement { [$1] }
    | Statements NEWLINE Statement { $1 @ [$3] }

Statement:
    | LetStatement { $1 }
    | ExpressionStatement { $1 }
    | IfStatement { $1 }
    | MatchStatement { $1 }
    | WhileStatement { $1 }

IfStatement:
    | IF Expression THEN BlockStatements Else { IfThenElse ($2, $4, $5) }

Else:
    | /* empty */ { [] }
    | NEWLINE ELSE BlockStatements { $3 }

BlockStatements:
    | Statement { [$1] }
    | INDENT Statements DEDENT { $2 }
 
LetStatement:
    | LET ID BIND BlockStatements { Let ($2, $4) }

ExpressionStatement:
    | Expression { Return $1 }


MatchStatement:
    | MATCH Expression WITH INDENT MatchCases DEDENT { Match ($2, $5) }

MatchCases:
    | MatchCase { [$1] }
    | MatchCases NEWLINE MatchCase { $1 @ [ $3 ] }

MatchCase:
    | Expression FAT_ARROW BlockStatements { $1, $3 }

WhileStatement:
    | WHILE Expression DO INDENT BlockStatements { While ($2, $5) }

Expression:
    | NUMBER { Number $1 }
    | ID { Symbol $1 }
    | Expression PLUS Expression { Function (Plus, $1, $3) }
    | Expression MINUS Expression { Function (Minus, $1, $3) }
    | Expression TIMES Expression { Function (Times, $1, $3) }
    | Expression DIVIDE Expression { Function (Divide, $1, $3) }
    | Expression EQUAL Expression { Function (Equal, $1, $3) }
    | Expression NOT_EQUAL Expression { Function (NotEqual, $1, $3) }
    | Expression LT Expression { Function (LowerThan, $1, $3) }
    | Expression LT_EQUAL Expression { Function (LowerThanOrEqual, $1, $3) }
    | Expression GT Expression { Function (GreaterThan, $1, $3) }
    | Expression GT_EQUAL Expression { Function (GreaterThanOrEqual, $1, $3) }
    | Expression AND Expression { Function (And, $1, $3) }
    | Expression OR Expression { Function (Or, $1, $3) }
    | LPAREN Expression RPAREN { $2 }
    | ID LPAREN CallTupleArgs RPAREN { FunctionCall ($1, $3) }

CallTupleArgs:
    | /* empty */ { [] }
    | CallArgs { $1 }

CallArgs:
    | Expression { [$1] }
    | CallArgs COMMA Expression { $1 @ [ $3 ] }

CallPartialArgs:
    | Expression { [$1] }
    | CallPartialArgs Expression { $1 @ [ $2 ] }
