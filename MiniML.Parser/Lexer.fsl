{
// module Lexer

open MiniML.Parser  // we need the terminal tokens from the Parser
open FSharp.Text.Lexing
open MiniML.LexerHelpers
 
let lexeme = LexBuffer<_>.LexemeString
}

let integer = ['1'-'9'] ['0'-'9']* | '-'? '0'*
let pointfloat = '-'? ['0'-'9']* '.' ['0'-'9']* | ['0'-'9']+ '.'
let newline = [' ' '\t']* ['\r' '\n']
let id = ['a'-'z' 'A'-'Z' '_'] ['a'-'z' 'A'-'Z' '_' '0'-'9']*
let string_char = [^ '\n' '\'' '"' '\\'] | '\\' _
let whitespace = [' ' '\t']+
let ws_comment = [' ' '\t']+'#'

rule read_one = parse
    | "=="       { EQUAL }
    | "<>"       { NOT_EQUAL }
    | '<'        { LT }
    | '>'        { GT }
    | "<="       { LT_EQUAL }
    | ">="       { GT_EQUAL }  
    | "&&"       { AND }
    | "||"       { OR }
    | '='        { BIND }
    | '+'        { PLUS }
    | '-'        { MINUS }
    | '*'        { TIMES }
    | '/'        { DIVIDE }
    | '('        { on_enter_bracket LPAREN }
    | ')'        { on_leave_bracket RPAREN }
    | ','        { COMMA }
    | ';'        { SEMICOLON }
    | '|'        { PIPE }
    | "=>"       { FAT_ARROW }

    | integer    { NUMBER (lexeme lexbuf |> decimal) }
    | newline    { on_newline read_one lexbuf }
    | id         { on_id lexbuf }
    | whitespace { on_whitespace read_one lexbuf }
    | eof        { on_eof() }
    | _          { failwithf "unrecognized input: '%s'" <| lexeme lexbuf }

