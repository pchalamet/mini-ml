{
// module Lexer

open MiniML.Parser  // we need the terminal tokens from the Parser
open FSharp.Text.Lexing

let lexeme = LexBuffer<_>.LexemeString
}

let integer = ['1'-'9'] ['0'-'9']* | '-'? '0'*
let pointfloat = '-'? ['0'-'9']* '.' ['0'-'9']* | ['0'-'9']+ '.'
let newline = [' ' '\t']* ['\r' '\n']
let id = ['a'-'z' 'A'-'Z' '_'] ['a'-'z' 'A'-'Z' '_' '0'-'9']*
let string_char = [^ '\n' '\'' '"' '\\'] | '\\' _
let whitespace = [' ' '\t']+
let ws_comment = [' ' '\t']+'#'

rule read_one = parse
    | "=="       { EQUAL }
    | "<>"       { NOT_EQUAL }
    | '<'        { LT }
    | '>'        { GT }
    | "<="       { LT_EQUAL }
    | ">="       { GT_EQUAL }  
    | "&&"       { AND }
    | "||"       { OR }
    | '='        { BIND }
    | '+'        { PLUS }
    | '-'        { MINUS }
    | '*'        { TIMES }
    | '/'        { DIVIDE }
    | '('        { LPAREN }
    | ')'        { RPAREN }
    | ','        { COMMA }
    | ';'        { SEMICOLON }
    | '|'        { PIPE }
    | "=>"       { FAT_ARROW }

    | "module"   { MODULE }
    | "if"       { IF }
    | "then"     { THEN }
    | "else"     { ELSE }

    | integer    { lexbuf |> lexeme |> decimal |> NUMBER }
    | newline    { lexbuf.EndPos <- lexbuf.EndPos.NextLine; NEWLINE }
    | id         { lexbuf |> lexeme |> ID }
    | whitespace { read_one lexbuf }
    | eof        { EOF }
    | _          { failwithf $"unrecognized input: '{lexeme lexbuf}'" }
